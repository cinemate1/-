<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Pink Gold Xmas Tree - High Brightness</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050204; font-family: 'Helvetica Neue', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 30px; left: 30px; color: #e0bfb8;
            text-shadow: 0 0 15px rgba(224, 191, 184, 0.6); pointer-events: none; z-index: 10;
        }
        canvas#output_canvas { position: absolute; bottom: 20px; right: 20px; width: 180px; height: 135px; border-radius: 12px; border: 1px solid #e0bfb8; transform: scaleX(-1); opacity: 0.6; }
        .loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: #e0bfb8; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
    </style>
</head>
<body>

<div id="loading" class="loading">
    <div>âœ¨ æ­£åœ¨ç‚¹äº® 15000 é¢—é«˜äº®ç²’å­...</div>
    <div style="font-size: 12px; margin-top: 10px; opacity: 0.6;">é¦–æ¬¡åŠ è½½ AI æ¨¡å‹çº¦éœ€ 10 ç§’</div>
</div>

<div id="ui">
    <h1 style="font-size: 2em; margin: 0; letter-spacing: 2px; color: #ffccaa;">Merry Christmas</h1>
    <p id="gesture-hint" style="opacity: 0.8;">ç­‰å¾…æ‰‹åŠ¿å¯åŠ¨ (âœŠåˆæ‹¢ ğŸ–ï¸æ•£å¼€)</p>
</div>

<div id="container"></div>
<canvas id="output_canvas"></canvas>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

// --- é…ç½® ---
const CONFIG = {
    colors: {
        pinkGold: 0xffb6c1, // äº®ç²‰è‰²
        roseGold: 0xe0bfb8, // ç«ç‘°é‡‘
        gold: 0xffd700,     // çº¯é‡‘
        orange: 0xffaa00,   // äº®æ©™
        bg: 0x050204        // ææ·±èƒŒæ™¯
    },
    particleCount: 15000,
    treeHeight: 14,
    baseRadius: 6
};

let scene, camera, renderer, composer, handLandmarker;
let star, particleSystem, textMesh;
let currentState = 'CLOSE';
let targetRot = { x: 0, y: 0 }, curRot = { x: 0, y: 0 };

async function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.colors.bg);
    scene.fog = new THREE.Fog(CONFIG.colors.bg, 10, 60);

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 22); // ç›¸æœºè§†è§’å¾®è°ƒ

    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    // ä½¿ç”¨ ACESFilmic è‰²è°ƒæ˜ å°„ï¼Œå¯ä»¥æ›´å¥½åœ°å¤„ç†é«˜äº®é¢œè‰²
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.getElementById('container').appendChild(renderer.domElement);

    // --- åæœŸå¤„ç†ï¼šè¶…äº®è¾‰å…‰ ---
    const renderPass = new RenderPass(scene, camera);
    // å¼ºåº¦è°ƒè‡³ 2.5ï¼ŒåŠå¾„ 0.6ï¼Œé˜ˆå€¼ 0.2 (è®©æ›´å¤šæš—éƒ¨ç²’å­ä¹Ÿèƒ½å‘å…‰)
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.6, 0.2);
    composer = new EffectComposer(renderer);
    composer.addPass(renderPass);
    composer.addPass(bloomPass);

    // å¢åŠ ç¯å¢ƒå…‰ç…§äº®æ–‡å­—
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // å¢åŠ ä¸€æŸèšå…‰ç¯ç…§äº®ä¸­é—´çš„æ–‡å­—
    const spotLight = new THREE.SpotLight(0xffeebb, 10);
    spotLight.position.set(0, 10, 10);
    spotLight.lookAt(0, 0, 0);
    scene.add(spotLight);

    createStar();
    createParticles();
    createCenterText(); // æ”¹åä¸ºåˆ›å»ºå±…ä¸­æ–‡å­—
    await initHandTracking();

    document.getElementById('loading').style.display = 'none';
    animate();
}

// 1. å›ºå®šä¸åŠ¨çš„æ˜Ÿæ˜Ÿ
function createStar() {
    const shape = new THREE.Shape();
    const spikes = 5, outer = 1.0, inner = 0.45;
    for (let i = 0; i < spikes * 2; i++) {
        let r = i % 2 === 0 ? outer : inner;
        let a = (i / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
        if (i === 0) shape.moveTo(Math.cos(a) * r, Math.sin(a) * r);
        else shape.lineTo(Math.cos(a) * r, Math.sin(a) * r);
    }
    const geometry = new THREE.ExtrudeGeometry(shape, { depth: 0.2, bevelEnabled: true, bevelSize: 0.05 });
    const material = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.gold,
        metalness: 1.0, roughness: 0.1,
        emissive: CONFIG.colors.gold, emissiveIntensity: 2.0 // æ˜Ÿæ˜Ÿäº®åº¦
    });
    star = new THREE.Mesh(geometry, material);
    star.position.y = CONFIG.treeHeight * 0.5 + 0.5;
    // ç¨å¾®ä¿®æ­£è§’åº¦è®©å®ƒæ­£å¯¹å‰æ–¹ï¼Œä¸”ä¸å†åœ¨ animate ä¸­æ—‹è½¬
    star.rotation.z = 0;
    scene.add(star);
}

// 2. å±…ä¸­çš„ç²‰é‡‘è‰ºæœ¯å­—
function createCenterText() {
    const loader = new FontLoader();
    // ä½¿ç”¨ Optimer å­—ä½“ï¼Œæ¯”é»˜è®¤çš„æ›´æœ‰è‰ºæœ¯æ„Ÿï¼Œæ¥è¿‘æ‰‹å†™é£æ ¼
    loader.load('https://unpkg.com/three@0.160.0/examples/fonts/optimer_bold.typeface.json', (font) => {
        const textGeo = new TextGeometry('Merry Christmas', {
            font: font,
            size: 1.5, // å­—ä½“å˜å¤§
            height: 0.2,
            curveSegments: 12,
            bevelEnabled: true,
            bevelThickness: 0.03,
            bevelSize: 0.02
        });
        textGeo.center();

        // ç²‰é‡‘æè´¨
        const textMat = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.pinkGold,
            metalness: 0.9,
            roughness: 0.1, // åƒæŠ›å…‰é‡‘å±ä¸€æ ·å…‰æ»‘
            emissive: CONFIG.colors.pinkGold,
            emissiveIntensity: 0.8
        });

        textMesh = new THREE.Mesh(textGeo, textMat);
        // ä½ç½®è®¾ç½®åœ¨ Y=0 (å‚ç›´å±…ä¸­), Z=4 (å‘å¤–çªå‡ºï¼Œé¿å…è¢«ç²’å­å®Œå…¨æ·¹æ²¡)
        textMesh.position.set(0, 0, 4.5);
        scene.add(textMesh);
    });
}

// 3. è¶…äº®ç²’å­ç³»ç»Ÿ
function createParticles() {
    const pData = [];
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const colors = new Float32Array(CONFIG.particleCount * 3);

    const colorPalette = [
        new THREE.Color(CONFIG.colors.pinkGold),
        new THREE.Color(CONFIG.colors.gold),
        new THREE.Color(CONFIG.colors.orange)
    ];
    const tempColor = new THREE.Color();

    for (let i = 0; i < CONFIG.particleCount; i++) {
        // åœ†é”¥ç»“æ„
        const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight * 0.5;
        const r = (CONFIG.treeHeight * 0.5 - h) / CONFIG.treeHeight * CONFIG.baseRadius * (0.8 + Math.random() * 0.4);
        const a = Math.random() * Math.PI * 2;

        const close = new THREE.Vector3(Math.cos(a) * r, h, Math.sin(a) * r);
        const scatter = new THREE.Vector3((Math.random()-0.5)*45, (Math.random()-0.5)*45, (Math.random()-0.5)*45);

        pData.push({ close, scatter, current: close.clone(), phase: Math.random() * 10 });

        positions[i*3] = close.x;
        positions[i*3+1] = close.y;
        positions[i*3+2] = close.z;

        // é¢œè‰²è¶…äº®å¤„ç†
        const colorIndex = Math.floor(Math.random() * colorPalette.length);
        tempColor.copy(colorPalette[colorIndex]);

        // å…³é”®ï¼šå°†é¢œè‰²æ•°å€¼ä¹˜ä»¥ 2.0ï¼Œä½¿å…¶åœ¨ ToneMapping ä¸­è¡¨ç°ä¸ºé«˜äº®å‘å…‰ä½“
        tempColor.multiplyScalar(2.0 + Math.random() * 1.0);

        colors[i*3] = tempColor.r;
        colors[i*3+1] = tempColor.g;
        colors[i*3+2] = tempColor.b;
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.05, // ç²’å­ç¨å¾®å˜å¤§ä¸€ç‚¹ç‚¹ï¼Œå¢åŠ å¯è§åº¦
        vertexColors: true,
        transparent: true,
        opacity: 1.0, // ä¸é€æ˜åº¦æ‹‰æ»¡
        blending: THREE.AdditiveBlending, // å åŠ å‘å…‰
        depthWrite: false
    });

    particleSystem = new THREE.Points(geometry, material);
    particleSystem.userData.data = pData;
    scene.add(particleSystem);
}

async function initHandTracking() {
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
        runningMode: "VIDEO", numHands: 1
    });
    const video = document.createElement('video');
    navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
        video.srcObject = stream; video.play();
        const detect = () => {
            if (video.currentTime !== -1) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                if (results.landmarks && results.landmarks.length > 0) {
                    const marks = results.landmarks[0];
                    const dist = Math.hypot(marks[8].x - marks[0].x, marks[8].y - marks[0].y);
                    if (dist < 0.25) currentState = 'CLOSE';
                    else {
                        currentState = 'SCATTER';
                        targetRot.y = (marks[8].x - 0.5) * 2;
                        targetRot.x = (marks[8].y - 0.5) * 1.5;
                    }
                    document.getElementById('gesture-hint').innerText = currentState === 'CLOSE' ? "âœ¨ ç²’å­å‡èš..." : "ğŸŒŒ ç²’å­æ•£å¼€...";
                }
            }
            requestAnimationFrame(detect);
        };
        detect();
    });
}

function animate() {
    const time = performance.now() * 0.001;
    curRot.x += (targetRot.x - curRot.x) * 0.05;
    curRot.y += (targetRot.y - curRot.y) * 0.05;
    // åœºæ™¯æ—‹è½¬
    scene.rotation.set(curRot.x * 0.3, curRot.y, 0);

    // æ³¨æ„ï¼šå·²ç§»é™¤ star.rotation.z çš„ä»£ç ï¼Œæ˜Ÿæ˜Ÿç°åœ¨æ˜¯å›ºå®šçš„

    // æ–‡å­—æµ®åŠ¨æ•ˆæœ (ä¸Šä¸‹è½»å¾®æ¼‚æµ®)
    if(textMesh) {
        textMesh.position.y = Math.sin(time) * 0.2;
        textMesh.lookAt(camera.position); // è®©æ–‡å­—å§‹ç»ˆç¨å¾®æœå‘ç›¸æœºï¼Œä¿è¯å¯è¯»æ€§
    }

    if (particleSystem) {
        const positions = particleSystem.geometry.attributes.position.array;
        const data = particleSystem.userData.data;
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const p = data[i];
            const target = currentState === 'CLOSE' ? p.close : p.scatter;
            p.current.lerp(target, 0.06);
            // å¿«é€Ÿé—ªçƒæ•ˆæœ
            const offset = Math.sin(time * 3 + p.phase) * 0.05;
            positions[i*3] = p.current.x;
            positions[i*3+1] = p.current.y + offset;
            positions[i*3+2] = p.current.z;
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;
    }

    composer.render();
    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>