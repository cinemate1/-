<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Pink Gold Cone Tree - Corrected Star</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #container { width: 100vw; height: 100vh; }

        /* 连笔花体字样式 */
        #title-overlay {
            position: absolute;
            bottom: 12%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
            width: 100%;
        }

        h1 {
            font-family: 'Great Vibes', cursive;
            font-size: 5.5em;
            margin: 0;
            font-weight: normal;
            background: linear-gradient(to bottom, #ffd700, #ff8c00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.6));
            letter-spacing: 3px;
        }
    </style>
</head>
<body>

<div id="title-overlay">
    <h1>Merry Christmas</h1>
</div>

<div id="container"></div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

const CONFIG = {
    colors: {
        pinkBright: 0xff1493, // 亮粉
        pinkLight: 0xff69b4,  // 浅粉
        pinkSoft: 0xffb6c1,   // 柔粉
        gold: 0xffd700,       // 金色
        orange: 0xff8c00      // 橙色(点缀)
    },
    particleCount: 20000,
    treeHeight: 18,     // 树高
    baseRadius: 6.5     // 底部半径
};

let scene, camera, renderer, composer, controls;
let particleSystem, starMesh;

init();

function init() {
    // 1. 场景
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.03); // 雾化增强景深

    // 2. 相机
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 28);

    // 3. 渲染器
    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.getElementById('container').appendChild(renderer.domElement);

    // 4. 后期辉光
    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.5, 0.1);
    composer = new EffectComposer(renderer);
    composer.addPass(renderPass);
    composer.addPass(bloomPass);

    // 5. 控制器
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.0;
    controls.target.set(0, CONFIG.treeHeight * 0.4, 0);

    // 6. 创建物体
    createStraightStar(); // 正星星
    createConeTree();     // 圆锥树

    // 地面反光
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshBasicMaterial({ color: 0xff1493, transparent: true, opacity: 0.05 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1; // 略微下移
    scene.add(ground);

    window.addEventListener('resize', onWindowResize);
    animate();
}

// --- 修改 1：摆正的星星 ---
function createStraightStar() {
    const shape = new THREE.Shape();
    const spikes = 5;
    const outerRadius = 1.6;
    const innerRadius = 0.7;

    for (let i = 0; i < spikes * 2; i++) {
        const r = (i % 2 === 0) ? outerRadius : innerRadius;
        // 修改：+ Math.PI / 2 确保第一个角垂直向上 (12点钟方向)
        const angle = (i / (spikes * 2)) * Math.PI * 2 + Math.PI / 2;

        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;

        if (i === 0) shape.moveTo(x, y);
        else shape.lineTo(x, y);
    }

    const extrudeSettings = {
        depth: 0.4,
        bevelEnabled: true,
        bevelThickness: 0.1,
        bevelSize: 0.1,
        bevelSegments: 2
    };

    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    // 材质：高亮金色
    const material = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.gold,
        emissive: CONFIG.colors.gold,
        emissiveIntensity: 3.5,
        roughness: 0.1,
        metalness: 1.0
    });

    starMesh = new THREE.Mesh(geometry, material);
    // 位置：树顶
    starMesh.position.y = CONFIG.treeHeight + 0.5;
    // 确保不旋转 Z 轴
    starMesh.rotation.z = 0;
    scene.add(starMesh);

    // 增加点光源
    const light = new THREE.PointLight(CONFIG.colors.gold, 2, 15);
    light.position.set(0, 0, 1);
    starMesh.add(light);
}

// --- 修改 2：圆锥形粒子树 ---
function createConeTree() {
    const positions = [];
    const colors = [];
    const colorHelper = new THREE.Color();
    const palette = [
        CONFIG.colors.pinkBright,
        CONFIG.colors.pinkLight,
        CONFIG.colors.pinkSoft,
        CONFIG.colors.gold,
        CONFIG.colors.orange
    ];

    for(let i = 0; i < CONFIG.particleCount; i++) {
        // 1. 高度生成：线性分布，从 0 到 树高
        const h = Math.random() * CONFIG.treeHeight;

        // 2. 半径生成：标准的圆锥公式
        // 底部半径最大，顶部半径趋近于0
        const heightRatio = h / CONFIG.treeHeight; // 0(底) -> 1(顶)
        const maxRadiusAtHeight = CONFIG.baseRadius * (1 - heightRatio);

        // 使用 sqrt 保证粒子在圆截面内分布均匀，而不是聚集在中心
        const r = maxRadiusAtHeight * Math.sqrt(Math.random());

        // 3. 角度生成
        const a = Math.random() * Math.PI * 2;

        // 4. 坐标计算
        // 加上一点点随机扰动(jitter)，让树看起来毛茸茸，不那么像数学模型
        const jitter = 0.2;
        const x = Math.cos(a) * r + (Math.random()-0.5) * jitter;
        const y = h + (Math.random()-0.5) * jitter;
        const z = Math.sin(a) * r + (Math.random()-0.5) * jitter;

        positions.push(x, y, z);

        // 5. 颜色分配与高亮
        const hex = palette[Math.floor(Math.random() * palette.length)];
        colorHelper.setHex(hex);

        // HDR 高亮处理 (倍增亮度)
        const brightness = 1.5 + Math.random() * 2.0;
        colorHelper.multiplyScalar(brightness);

        colors.push(colorHelper.r, colorHelper.g, colorHelper.b);
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    // 圆形纹理
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16,16,0,16,16,16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.5, 'rgba(255,255,255,0.8)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,32,32);
    const texture = new THREE.CanvasTexture(canvas);

    const material = new THREE.PointsMaterial({
        size: 0.12,
        map: texture,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();

    const time = Date.now() * 0.001;

    // 粒子整体缓慢旋转
    if(particleSystem) {
        particleSystem.rotation.y = time * 0.1;
    }

    // 星星缓慢浮动 (不旋转，只上下浮动)
    if(starMesh) {
        starMesh.position.y = CONFIG.treeHeight + 0.5 + Math.sin(time * 2) * 0.1;
    }

    composer.render();
}
</script>
</body>
</html>
